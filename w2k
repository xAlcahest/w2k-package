#!/bin/bash

# WebtoonDL to Kavita Format Converter (w2k)
# Script unificato per download, conversione e automazione webtoon per Kavita
# 
# Utilizzo:
#   ./w2k [directory_source] [directory_output]     # Modalità conversione
#   ./w2k --setup                                   # Setup guidato
#   ./w2k --download <url>                          # Download e conversione
#   ./w2k --auto                                    # Automazione completa
#   ./w2k --help                                    # Mostra aiuto
#
# Configurazione salvata in ~/.config/w2k/config

# Note: set -e temporarily disabled due to compatibility issues with some shell commands
# that return non-zero exit codes in specific edge cases. The script handles errors
# explicitly where needed.
set -o pipefail

# Colori per output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Configurazione
CONFIG_DIR="$HOME/.config/w2k"
CONFIG_FILE="$CONFIG_DIR/config"
SERIES_DB="$CONFIG_DIR/series.db"
LOCKFILE="$CONFIG_DIR/w2k.lock"
WEBTOON_DOWNLOADER_DIR=""
DOWNLOAD_DIR=""
KAVITA_BASE_URL=""
KAVITA_API_KEY=""
KAVITA_LIBRARY_ID=""

# Funzione per stampare help
show_help() {
    cat << EOF
WebtoonDL to Kavita Format Converter (w2k)
Script unificato per download, conversione e automazione webtoon per Kavita

UTILIZZO:
    $0 [OPZIONI] [SOURCE_DIR] [OUTPUT_DIR]

MODALITÀ:
    CONVERSIONE (default):
        $0 [SOURCE_DIR] [OUTPUT_DIR]     # Converte directory esistenti
    
    SETUP:
        $0 --setup                       # Setup guidato configurazione
    
    DOWNLOAD:
        $0 --download <url>              # Download e conversione automatica
        $0 --download-only <url>         # Solo download senza conversione
    
    AUTOMAZIONE:
        $0 --auto                        # Controlla aggiornamenti e converte
        $0 --auto --force                # Forza ri-download di tutto

OPZIONI CONVERSIONE:
    -h, --help              Mostra questo messaggio di aiuto
    -v, --verbose           Output verboso
    --dry-run              Simula le operazioni senza eseguirle
    --no-cbz               Non creare file CBZ (solo conversione directory)
    --force                Sovrascrive directory di output esistenti

OPZIONI DOWNLOAD WEBTOON:
    --start <num>          Capitolo iniziale da scaricare
    --end <num>            Capitolo finale da scaricare
    --latest               Scarica solo l'ultimo capitolo
    --quality <40-100>     Qualità immagini (default: 100)
    --format <jpg|png>     Formato immagini (default: jpg)
    --concurrent-chapters <num>  Capitoli simultanei (default: 3)
    --concurrent-pages <num>     Pagine simultanee (default: 5)

OPZIONI AUTOMAZIONE:
    --setup                Setup guidato per configurazione iniziale
    --download <url>       Download webtoon da URL e conversione
    --download-only <url>  Solo download webtoon da URL
    --add-series <url>     Aggiungi serie per controllo automatico
    --remove-series <url>  Rimuovi serie dal controllo automatico
    --list-series          Mostra serie monitorate
    --check-updates        Controlla aggiornamenti per tutte le serie
    --auto                 Modalità automazione (controlla aggiornamenti)
    --notify-kavita        Notifica Kavita al termine (richiede setup)
    --cron                 Modalità cron (output ridotto)

CONFIGURAZIONE:
    File di configurazione: $CONFIG_FILE
    - Percorso Webtoon-Downloader
    - Directory di download
    - URL e credenziali Kavita
    - ID library Kavita

FORMATO KAVITA:
    Input:  Episode 45/
    Output: Series Volume 1 Chapter 45.cbz

    Input:  (S2) Episode 123/
    Output: Series Volume 2 Chapter 123.cbz

ESEMPI:
    # Setup iniziale
    $0 --setup

    # Conversione directory esistente
    $0 /path/to/webtoons kavita_output

    # Download e conversione completa
    $0 --download "https://www.webtoons.com/en/drama/example/list?title_no=123"

    # Download solo capitoli specifici
    $0 --download "https://..." --start 10 --end 20

    # Download ultimo capitolo solo
    $0 --download "https://..." --latest

    # Aggiungi serie per monitoraggio automatico
    $0 --add-series "https://www.webtoons.com/en/drama/example/list?title_no=123"

    # Lista serie monitorate
    $0 --list-series

    # Controlla aggiornamenti per tutte le serie
    $0 --check-updates

    # Modalità cron (ogni 6 ore) per monitoraggio automatico
    $0 --auto --cron

    # Test configurazione
    $0 --dry-run --auto

EOF
}

# Variabili globali
VERBOSE=0
DRY_RUN=0
CREATE_CBZ=1
FORCE=0
SOURCE_DIR=""
OUTPUT_DIR=""
MODE="convert"  # convert, setup, download, auto
WEBTOON_URL=""
NOTIFY_KAVITA=0
CRON_MODE=0

# Opzioni Webtoon Downloader
WD_START=""           # Capitolo iniziale
WD_END=""             # Capitolo finale
WD_LATEST=0           # Solo ultimo capitolo
WD_QUALITY=100        # Qualità immagini (40-100)
WD_FORMAT="jpg"       # Formato immagini (jpg/png)
WD_CONCURRENT_CHAPTERS=3  # Download capitoli simultanei
WD_CONCURRENT_PAGES=5     # Download pagine simultanee

# Funzioni per output
print_info() {
    if [[ $CRON_MODE -eq 0 ]]; then
        echo -e "${BLUE}[INFO]${NC} $1"
    fi
}

print_success() {
    if [[ $CRON_MODE -eq 0 ]]; then
        echo -e "${GREEN}[SUCCESS]${NC} $1"
    fi
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1" >&2
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

print_verbose() {
    if [[ $VERBOSE -eq 1 && $CRON_MODE -eq 0 ]]; then
        echo -e "${CYAN}[VERBOSE]${NC} $1"
    fi
}

# Parsing argomenti
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -v|--verbose)
                VERBOSE=1
                shift
                ;;
            --dry-run)
                DRY_RUN=1
                shift
                ;;
            --no-cbz)
                CREATE_CBZ=0
                shift
                ;;
            --force)
                FORCE=1
                shift
                ;;
            --setup)
                MODE="setup"
                shift
                ;;
            --download)
                MODE="download"
                if [[ $# -lt 2 ]]; then
                    print_error "--download richiede un URL"
                    exit 1
                fi
                WEBTOON_URL="$2"
                shift 2
                ;;
            --download-only)
                MODE="download-only"
                if [[ $# -lt 2 ]]; then
                    print_error "--download-only richiede un URL"
                    exit 1
                fi
                WEBTOON_URL="$2"
                shift 2
                ;;
            --auto)
                MODE="auto"
                shift
                ;;
            --notify-kavita)
                NOTIFY_KAVITA=1
                shift
                ;;
            --start)
                if [[ $# -lt 2 ]]; then
                    print_error "--start richiede un numero di capitolo"
                    exit 1
                fi
                WD_START="$2"
                shift 2
                ;;
            --end)
                if [[ $# -lt 2 ]]; then
                    print_error "--end richiede un numero di capitolo"
                    exit 1
                fi
                WD_END="$2"
                shift 2
                ;;
            --latest)
                WD_LATEST=1
                shift
                ;;
            --quality)
                if [[ $# -lt 2 ]]; then
                    print_error "--quality richiede un valore 40-100"
                    exit 1
                fi
                WD_QUALITY="$2"
                if [[ ! "$WD_QUALITY" =~ ^[0-9]+$ ]] || [[ $WD_QUALITY -lt 40 ]] || [[ $WD_QUALITY -gt 100 ]]; then
                    print_error "Qualità deve essere tra 40 e 100"
                    exit 1
                fi
                shift 2
                ;;
            --format)
                if [[ $# -lt 2 ]]; then
                    print_error "--format richiede jpg o png"
                    exit 1
                fi
                case "$2" in
                    jpg|png)
                        WD_FORMAT="$2"
                        ;;
                    *)
                        print_error "Formato deve essere jpg o png"
                        exit 1
                        ;;
                esac
                shift 2
                ;;
            --concurrent-chapters)
                if [[ $# -lt 2 ]]; then
                    print_error "--concurrent-chapters richiede un numero"
                    exit 1
                fi
                WD_CONCURRENT_CHAPTERS="$2"
                shift 2
                ;;
            --concurrent-pages)
                if [[ $# -lt 2 ]]; then
                    print_error "--concurrent-pages richiede un numero"
                    exit 1
                fi
                WD_CONCURRENT_PAGES="$2"
                shift 2
                ;;
            --add-series)
                MODE="add-series"
                if [[ $# -lt 2 ]]; then
                    print_error "--add-series richiede un URL"
                    exit 1
                fi
                WEBTOON_URL="$2"
                shift 2
                ;;
            --remove-series)
                MODE="remove-series"
                if [[ $# -lt 2 ]]; then
                    print_error "--remove-series richiede un URL"
                    exit 1
                fi
                WEBTOON_URL="$2"
                shift 2
                ;;
            --list-series)
                MODE="list-series"
                shift
                ;;
            --check-updates)
                MODE="check-updates"
                shift
                ;;
            --cron)
                CRON_MODE=1
                shift
                ;;
            -*)
                print_error "Opzione sconosciuta: $1"
                show_help
                exit 1
                ;;
            *)
                if [[ "$MODE" == "convert" ]]; then
                    if [[ -z "$SOURCE_DIR" ]]; then
                        SOURCE_DIR="$1"
                    elif [[ -z "$OUTPUT_DIR" ]]; then
                        OUTPUT_DIR="$1"
                    else
                        print_error "Troppi argomenti"
                        show_help
                        exit 1
                    fi
                else
                    print_error "Argomento non supportato in modalità $MODE: $1"
                    exit 1
                fi
                shift
                ;;
        esac
    done

    # Imposta valori di default per modalità conversione
    if [[ "$MODE" == "convert" ]]; then
        [[ -z "$SOURCE_DIR" ]] && SOURCE_DIR="."
        [[ -z "$OUTPUT_DIR" ]] && OUTPUT_DIR="kavita_output"
    fi
}

# Carica configurazione
load_config() {
    if [[ -f "$CONFIG_FILE" ]]; then
        print_verbose "Caricando configurazione da $CONFIG_FILE"
        source "$CONFIG_FILE"
    else
        print_verbose "File di configurazione non trovato: $CONFIG_FILE"
    fi
}

# Salva configurazione
save_config() {
    mkdir -p "$CONFIG_DIR"
    cat > "$CONFIG_FILE" << EOF
# Configurazione w2k
WEBTOON_DOWNLOADER_DIR="$WEBTOON_DOWNLOADER_DIR"
DOWNLOAD_DIR="$DOWNLOAD_DIR"
KAVITA_BASE_URL="$KAVITA_BASE_URL"
KAVITA_API_KEY="$KAVITA_API_KEY"
KAVITA_LIBRARY_ID="$KAVITA_LIBRARY_ID"
EOF
    print_success "Configurazione salvata in $CONFIG_FILE"
}

# Validazione configurazione
validate_config() {
    local errors=0
    
    if [[ -z "$WEBTOON_DOWNLOADER_DIR" || ! -d "$WEBTOON_DOWNLOADER_DIR" ]]; then
        print_error "Directory Webtoon-Downloader non trovata: $WEBTOON_DOWNLOADER_DIR"
        errors=$((errors + 1))
    fi
    
    if [[ -z "$DOWNLOAD_DIR" ]]; then
        print_error "Directory download non impostata"
        errors=$((errors + 1))
    fi
    
    if [[ $NOTIFY_KAVITA -eq 1 || "$MODE" == "auto" ]]; then
        if [[ -z "$KAVITA_BASE_URL" ]]; then
            print_error "URL Kavita non impostato"
            errors=$((errors + 1))
        fi
        
        if [[ -z "$KAVITA_API_KEY" ]]; then
            print_error "API Key Kavita non impostata"
            errors=$((errors + 1))
        fi
        
        # KAVITA_LIBRARY_ID è opzionale, non è un errore se vuoto
    fi
    
    return $errors
}

# Setup guidato
setup_wizard() {
    print_info "=== SETUP GUIDATO W2K ==="
    echo
    
    print_info "Configurazione Webtoon-Downloader"
    echo "Il script richiede Webtoon-Downloader per scaricare i webtoon."
    echo "Repository: https://github.com/Zehina/Webtoon-Downloader"
    echo
    
    while true; do
        read -p "Percorso directory Webtoon-Downloader [Enter per cercare automaticamente]: " input
        
        if [[ -z "$input" ]]; then
            # Cerca automaticamente
            local candidates=(
                "$HOME/Webtoon-Downloader"
                "$HOME/git/Webtoon-Downloader" 
                "./Webtoon-Downloader"
                "../Webtoon-Downloader"
            )
            
            for candidate in "${candidates[@]}"; do
                if [[ -d "$candidate" && -f "$candidate/main.py" ]]; then
                    WEBTOON_DOWNLOADER_DIR="$candidate"
                    print_success "Trovato Webtoon-Downloader: $WEBTOON_DOWNLOADER_DIR"
                    break
                fi
            done
            
            if [[ -z "$WEBTOON_DOWNLOADER_DIR" ]]; then
                print_warning "Webtoon-Downloader non trovato automaticamente"
                echo "Clona il repository con: git clone https://github.com/Zehina/Webtoon-Downloader"
                continue
            fi
        else
            if [[ -d "$input" && -f "$input/main.py" ]]; then
                WEBTOON_DOWNLOADER_DIR="$input"
                print_success "Directory Webtoon-Downloader impostata: $WEBTOON_DOWNLOADER_DIR"
            else
                print_error "Directory non valida o main.py non trovato: $input"
                continue
            fi
        fi
        break
    done
    
    echo
    print_info "Configurazione Directory Download"
    while true; do
        read -p "Directory per download webtoon [$HOME/webtoons]: " input
        DOWNLOAD_DIR="${input:-$HOME/webtoons}"
        
        if [[ ! -d "$DOWNLOAD_DIR" ]]; then
            read -p "Directory non esiste. Crearla? [y/N]: " create
            if [[ "$create" =~ ^[Yy]$ ]]; then
                mkdir -p "$DOWNLOAD_DIR"
                print_success "Directory creata: $DOWNLOAD_DIR"
            else
                continue
            fi
        fi
        
        print_success "Directory download impostata: $DOWNLOAD_DIR"
        break
    done
    
    echo
    print_info "Configurazione Kavita (opzionale per automazione)"
    echo "Per usare l'automazione e le notifiche, configura Kavita."
    echo
    
    read -p "Configurare Kavita? [y/N]: " configure_kavita
    if [[ "$configure_kavita" =~ ^[Yy]$ ]]; then
        echo
        print_info "Configurazione URL Kavita"
        echo "Inserisci l'URL base del tuo server Kavita (es: http://localhost:5000)"
        read -p "URL Kavita: " KAVITA_BASE_URL
        
        echo
        print_info "Configurazione API Key Kavita"
        echo "Per trovare la tua API Key:"
        echo "1. Apri Kavita nel browser"
        echo "2. Vai in User Settings (icona utente in alto a destra)"
        echo "3. Clicca su '3rd Party Clients'"
        echo "4. Copia l'API Key mostrata"
        echo
        read -p "API Key Kavita: " KAVITA_API_KEY
        
        echo
        print_info "Test connessione Kavita..."
        if test_kavita_connection; then
            print_success "Connessione Kavita riuscita!"
            
            echo
            print_info "Configurazione Library ID"
            echo "Per automazione completa, specifica l'ID della library da aggiornare."
            echo "Lascia vuoto per aggiornare tutte le library."
            read -p "Library ID (opzionale): " KAVITA_LIBRARY_ID
        else
            print_warning "Test connessione fallito. Puoi configurare in seguito."
        fi
    fi
    
    echo
    print_info "Salvando configurazione..."
    save_config
    
    echo
    print_success "Setup completato!"
    echo
    print_info "Comandi utili:"
    echo "  $0 --download <url>    # Download e conversione"
    echo "  $0 --auto              # Automazione completa"
    echo "  $0 /path/to/series     # Conversione manuale"
}

# =======================================================================================
# FUNZIONI GESTIONE SERIE AUTOMATICA
# =======================================================================================

# Inizializza database serie
init_series_db() {
    mkdir -p "$CONFIG_DIR"
    
    if [[ ! -f "$SERIES_DB" ]]; then
        print_verbose "Creando database serie: $SERIES_DB"
        cat > "$SERIES_DB" << 'EOF'
# Database serie monitorate w2k
# Formato: URL|NOME_SERIE|TIMESTAMP_ULTIMO_CHECK|TIMESTAMP_AGGIUNTA
EOF
    fi
}

# Estrae informazioni da URL webtoon
extract_series_info() {
    local url="$1"
    local title_no=""
    local series_name=""
    
    # Estrai title_no dall'URL
    if [[ "$url" =~ title_no=([0-9]+) ]]; then
        title_no="${BASH_REMATCH[1]}"
    else
        print_error "URL non valido: impossibile estrarre title_no"
        return 1
    fi
    
    # Prova a estrarre il nome della serie dall'URL
    if [[ "$url" =~ /([^/]+)/list\?title_no= ]]; then
        series_name="${BASH_REMATCH[1]}"
        series_name=$(echo "$series_name" | tr '-' ' ' | sed 's/\b\w/\U&/g')
    else
        series_name="Series_$title_no"
    fi
    
    echo "${series_name}|${title_no}"
    return 0
}

# Aggiungi serie al monitoraggio
add_series() {
    local url="$1"
    
    init_series_db
    
    # Controlla se la serie è già presente
    if grep -q "^$url|" "$SERIES_DB" 2>/dev/null; then
        print_warning "Serie già presente nel monitoraggio"
        return 1
    fi
    
    # Estrai informazioni serie
    local info
    info=$(extract_series_info "$url")
    if [[ $? -ne 0 ]]; then
        return 1
    fi
    
    local series_name="${info%|*}"
    local timestamp_now
    timestamp_now=$(date +%s)
    
    # Aggiungi serie al database
    echo "$url|$series_name|0|$timestamp_now" >> "$SERIES_DB"
    
    print_success "Serie aggiunta: $series_name"
    print_info "URL: $url"
    print_info "Per controllare aggiornamenti usa: $0 --check-updates"
    
    return 0
}

# Rimuovi serie dal monitoraggio
remove_series() {
    local url="$1"
    
    if [[ ! -f "$SERIES_DB" ]]; then
        print_error "Database serie non trovato"
        return 1
    fi
    
    # Controlla se la serie esiste
    if ! grep -q "^$url|" "$SERIES_DB"; then
        print_error "Serie non trovata nel monitoraggio"
        return 1
    fi
    
    # Rimuovi serie
    local temp_file
    temp_file=$(mktemp)
    grep -v "^$url|" "$SERIES_DB" > "$temp_file"
    mv "$temp_file" "$SERIES_DB"
    
    print_success "Serie rimossa dal monitoraggio"
    return 0
}

# Lista serie monitorate
list_series() {
    if [[ ! -f "$SERIES_DB" ]]; then
        print_info "Nessuna serie nel monitoraggio"
        print_info "Usa: $0 --add-series <url> per aggiungere serie"
        return 0
    fi
    
    local count=0
    print_info "=== SERIE MONITORATE ==="
    
    while IFS='|' read -r url series_name last_check timestamp_added; do
        # Salta righe di commento
        [[ "$url" =~ ^#.*$ ]] && continue
        [[ -z "$url" ]] && continue
        
        count=$((count + 1))
        echo
        echo "[$count] $series_name"
        echo "    URL: $url"
        
        if [[ "$timestamp_added" != "0" ]]; then
            local date_added
            date_added=$(date -d "@$timestamp_added" '+%Y-%m-%d %H:%M' 2>/dev/null || echo "Data non disponibile")
            echo "    Aggiunta: $date_added"
        fi
        
        if [[ "$last_check" != "0" ]]; then
            local date_check
            date_check=$(date -d "@$last_check" '+%Y-%m-%d %H:%M' 2>/dev/null || echo "Mai controllata")
            echo "    Ultimo controllo: $date_check"
        else
            echo "    Ultimo controllo: Mai"
        fi
    done < "$SERIES_DB"
    
    if [[ $count -eq 0 ]]; then
        print_info "Nessuna serie nel monitoraggio"
        print_info "Usa: $0 --add-series <url> per aggiungere serie"
    else
        echo
        print_info "Totale serie monitorate: $count"
        print_info "Usa: $0 --check-updates per controllare aggiornamenti"
    fi
    
    return 0
}

# Controlla aggiornamenti per tutte le serie
check_updates() {
    if [[ ! -f "$SERIES_DB" ]]; then
        print_error "Database serie non trovato"
        print_info "Usa: $0 --add-series <url> per aggiungere serie"
        return 1
    fi
    
    # Controllo lockfile per evitare esecuzioni multiple
    if [[ -f "$LOCKFILE" ]]; then
        local lock_pid
        lock_pid=$(cat "$LOCKFILE" 2>/dev/null)
        if kill -0 "$lock_pid" 2>/dev/null; then
            print_warning "Check aggiornamenti già in corso (PID: $lock_pid)"
            return 1
        else
            print_verbose "Rimuovendo lockfile scaduto"
            rm -f "$LOCKFILE"
        fi
    fi
    
    # Crea lockfile
    echo $$ > "$LOCKFILE"
    trap 'rm -f "$LOCKFILE"' EXIT
    
    print_info "Controllo aggiornamenti serie..."
    
    local temp_db
    temp_db=$(mktemp)
    local updated_count=0
    local total_count=0
    
    while IFS='|' read -r url series_name last_check timestamp_added; do
        # Salta righe di commento o vuote
        [[ "$url" =~ ^#.*$ ]] && continue
        [[ -z "$url" ]] && continue
        
        total_count=$((total_count + 1))
        print_info "Controllando: $series_name"
        
        # Scarica ultimo capitolo
        WD_LATEST=1
        if download_webtoon "$url" "false"; then
            updated_count=$((updated_count + 1))
            print_success "Aggiornamenti trovati per: $series_name"
        else
            print_verbose "Nessun aggiornamento per: $series_name"
        fi
        
        # Aggiorna timestamp ultimo controllo
        local timestamp_now
        timestamp_now=$(date +%s)
        echo "$url|$series_name|$timestamp_now|$timestamp_added" >> "$temp_db"
        
        # Pausa tra le richieste per non sovraccaricare il server
        sleep 2
        
    done < "$SERIES_DB"
    
    # Sostituisci database con quello aggiornato
    mv "$temp_db" "$SERIES_DB"
    
    # Reset WD_LATEST
    WD_LATEST=0
    
    # Rimuovi lockfile
    rm -f "$LOCKFILE"
    
    print_info "Controllo completato"
    print_info "Serie controllate: $total_count"
    print_info "Serie aggiornate: $updated_count"
    
    if [[ $NOTIFY_KAVITA -eq 1 && $updated_count -gt 0 ]]; then
        notify_kavita_scan
    fi
    
    return 0
}

# Test connessione Kavita
test_kavita_connection() {
    if [[ -z "$KAVITA_BASE_URL" || -z "$KAVITA_API_KEY" ]]; then
        return 1
    fi
    
    local response
    response=$(curl -s -w "%{http_code}" \
        -X POST \
        -H "Content-Type: application/json" \
        -d "{\"apiKey\":\"$KAVITA_API_KEY\",\"pluginName\":\"w2k\"}" \
        "$KAVITA_BASE_URL/api/Plugin/authenticate" || echo "000")
    
    local http_code="${response: -3}"
    if [[ "$http_code" == "200" ]]; then
        return 0
    else
        print_verbose "HTTP Code: $http_code"
        return 1
    fi
}

# Ottieni JWT token da Kavita
get_kavita_token() {
    local response
    response=$(curl -s \
        -X POST \
        -H "Content-Type: application/json" \
        -d "{\"apiKey\":\"$KAVITA_API_KEY\",\"pluginName\":\"w2k\"}" \
        "$KAVITA_BASE_URL/api/Plugin/authenticate")
    
    if [[ $? -eq 0 ]]; then
        echo "$response" | grep -o '"token":"[^"]*"' | cut -d'"' -f4
    else
        return 1
    fi
}

# Notifica Kavita per scansione library
notify_kavita_scan() {
    if ! test_kavita_connection; then
        print_error "Connessione Kavita fallita"
        return 1
    fi
    
    local token
    token=$(get_kavita_token)
    if [[ -z "$token" ]]; then
        print_error "Impossibile ottenere token Kavita"
        return 1
    fi
    
    print_info "Notificando Kavita per scansione library..."
    
    local endpoint
    if [[ -n "$KAVITA_LIBRARY_ID" ]]; then
        endpoint="$KAVITA_BASE_URL/api/Library/scan?libraryId=$KAVITA_LIBRARY_ID&force=false"
    else
        endpoint="$KAVITA_BASE_URL/api/Library/scan-all?force=false"
    fi
    
    local response
    response=$(curl -s -w "%{http_code}" \
        -X POST \
        -H "Authorization: Bearer $token" \
        -H "Content-Type: application/json" \
        "$endpoint")
    
    local http_code="${response: -3}"
    if [[ "$http_code" == "200" ]]; then
        print_success "Scansione Kavita avviata"
        return 0
    else
        print_error "Errore notifica Kavita (HTTP: $http_code)"
        return 1
    fi
}

# Funzioni di conversione (dal w2k originale)
normalize_series_name() {
    local dir_name="$1"
    local dir_basename=$(basename "$dir_name")
    local parent_dir=$(basename "$(dirname "$dir_name")")
    
    # Prima prova con il nome della directory stessa
    if [[ "$dir_basename" != "." && "$dir_basename" != "/" ]]; then
        echo "$dir_basename" | sed 's/_/ /g'
    # Se la directory ha un nome generico, usa il nome della directory padre
    elif [[ "$parent_dir" != "." && "$parent_dir" != "/" ]]; then
        echo "$parent_dir" | sed 's/_/ /g'
    else
        echo "Series"
    fi
}

convert_episode_name() {
    local episode_dir="$1"
    local base_name=$(basename "$episode_dir")
    local series_name="$2"
    
    # Pattern per (S2) Episode 123 o Episode 123
    if [[ "$base_name" =~ ^\(S([0-9]+)\)[[:space:]]*Episode[[:space:]]*([0-9]+) ]]; then
        local season="${BASH_REMATCH[1]}"
        local episode="${BASH_REMATCH[2]}"
        echo "${series_name} Volume ${season} Chapter ${episode}"
    elif [[ "$base_name" =~ ^Episode[[:space:]]*([0-9]+) ]]; then
        local episode="${BASH_REMATCH[1]}"
        # Gli episodi senza stagione esplicita sono considerati Volume 1
        echo "${series_name} Volume 1 Chapter ${episode}"
    else
        print_warning "Formato non riconosciuto: $base_name"
        echo "${series_name} ${base_name}"
    fi
}

is_directory_empty() {
    local dir="$1"
    if [[ -d "$dir" ]]; then
        # Gestione esplicita dell'exit code per evitare problemi con set -e
        if ls -A "$dir" >/dev/null 2>&1; then
            local content
            content=$(ls -A "$dir" 2>/dev/null)
            [[ -z "$content" ]]
        else
            # Se ls fallisce, consideriamo la directory non vuota per sicurezza
            return 1
        fi
    else
        return 1
    fi
}

create_cbz_from_directory() {
    local source_dir="$1"
    local output_file="$2"
    
    if is_directory_empty "$source_dir"; then
        print_warning "Directory vuota, saltata: $(basename "$source_dir")"
        return 1
    fi
    
    print_verbose "Creando CBZ: $output_file"
    
    if [[ $DRY_RUN -eq 1 ]]; then
        local abs_output_file
        if [[ "$output_file" = /* ]]; then
            abs_output_file="$output_file"
        else
            abs_output_file="$(pwd)/$output_file"
        fi
        echo "[DRY-RUN] cd \"$source_dir\" && zip -rv0 \"$abs_output_file\" ."
        return 0
    fi
    
    local abs_output_file
    if [[ "$output_file" = /* ]]; then
        abs_output_file="$output_file"
    else
        abs_output_file="$(pwd)/$output_file"
    fi
    
    (cd "$source_dir" && zip -rv0 "$abs_output_file" . > /dev/null 2>&1)
    local exit_code=$?
    
    if [[ $exit_code -eq 0 ]]; then
        print_success "Creato: $(basename "$output_file")"
        return 0
    else
        print_error "Errore creazione CBZ: $output_file"
        return 1
    fi
}

# Conversione directory webtoon
convert_webtoon_directory() {
    local source_dir="$1"
    local output_dir="$2"
    
    if [[ ! -d "$source_dir" ]]; then
        print_error "Directory sorgente non trovata: $source_dir"
        return 1
    fi
    
    # Ottieni nome serie dalla directory
    local series_name
    series_name=$(normalize_series_name "$source_dir")
    print_info "Serie rilevata: $series_name"
    
    # Crea directory output se non esiste
    if [[ $DRY_RUN -eq 0 ]]; then
        if [[ -d "$output_dir" && $FORCE -eq 0 ]]; then
            print_error "Directory output esiste già: $output_dir (usa --force per sovrascrivere)"
            return 1
        fi
        
        mkdir -p "$output_dir"
        print_success "Directory output creata: $output_dir"
    fi
    
    local processed=0
    local skipped=0
    
    # Processa ogni episode directory
    for episode_dir in "$source_dir"/*; do
        print_verbose "Esaminando directory: $episode_dir"
        
        if [[ ! -d "$episode_dir" ]]; then
            print_verbose "Non è una directory, saltata: $(basename "$episode_dir")"
            continue
        fi
        
        local episode_name=$(basename "$episode_dir")
        print_verbose "Nome episodio: $episode_name"
        
        if [[ "$episode_name" == "file.txt" || "$episode_name" == "*.txt" ]]; then
            print_verbose "File di testo saltato: $episode_name"
            continue
        fi
        
        local converted_name
        print_verbose "Processando: $(basename "$episode_dir")"
        converted_name=$(convert_episode_name "$episode_dir" "$series_name")
        print_verbose "Nome convertito: $converted_name"
        
        if [[ $CREATE_CBZ -eq 1 ]]; then
            local output_file="$output_dir/${converted_name}.cbz"
            print_verbose "Creando CBZ per: $episode_name -> $output_file"
            
            if create_cbz_from_directory "$episode_dir" "$output_file"; then
                ((processed++))
                print_verbose "CBZ creato con successo"
            else
                ((skipped++))
                print_verbose "Creazione CBZ fallita"
            fi
        else
            local output_subdir="$output_dir/$converted_name"
            print_verbose "Copiando directory: $episode_name -> $output_subdir"
            
            if [[ $DRY_RUN -eq 1 ]]; then
                echo "[DRY-RUN] cp -r \"$episode_dir\" \"$output_subdir\""
                ((processed++))
            else
                if cp -r "$episode_dir" "$output_subdir" 2>/dev/null; then
                    print_success "Copiata: $converted_name"
                    ((processed++))
                else
                    print_error "Errore copia: $episode_name"
                    ((skipped++))
                fi
            fi
        fi
        
        print_verbose "Completato processamento di: $episode_name"
    done
    
    print_info "Conversione completata"
    print_info "Processati: $processed"
    if [[ $skipped -gt 0 ]]; then
        print_warning "Saltati: $skipped"
    fi
    
    return 0
}

# Download webtoon
download_webtoon() {
    local url="$1"
    local download_only="$2"
    
    if [[ -z "$WEBTOON_DOWNLOADER_DIR" || ! -d "$WEBTOON_DOWNLOADER_DIR" ]]; then
        print_error "Webtoon-Downloader non configurato. Esegui: $0 --setup"
        return 1
    fi
    
    print_info "Avviando download: $url"
    
    # Costruisci comando con opzioni
    local cmd="python -m webtoon_downloader.cmd.cli"
    cmd="$cmd \"$url\""
    cmd="$cmd --out \"$DOWNLOAD_DIR\""
    cmd="$cmd --save-as images --separate"
    cmd="$cmd --image-format $WD_FORMAT"
    cmd="$cmd --quality $WD_QUALITY"
    cmd="$cmd --concurrent-chapters $WD_CONCURRENT_CHAPTERS"
    cmd="$cmd --concurrent-pages $WD_CONCURRENT_PAGES"
    
    # Aggiungi opzioni condizionali
    if [[ -n "$WD_START" ]]; then
        cmd="$cmd --start $WD_START"
    fi
    if [[ -n "$WD_END" ]]; then
        cmd="$cmd --end $WD_END"
    fi
    if [[ $WD_LATEST -eq 1 ]]; then
        cmd="$cmd --latest"
    fi
    if [[ $VERBOSE -eq 1 ]]; then
        cmd="$cmd --debug"
    fi
    
    print_verbose "Comando: $cmd"
    
    if [[ $DRY_RUN -eq 1 ]]; then
        echo "[DRY-RUN] cd \"$WEBTOON_DOWNLOADER_DIR\" && $cmd"
        return 0
    fi
    
    # Salva timestamp per trovare directory create
    local timestamp_before
    timestamp_before=$(date +%s)
    
    # Esegui download
    print_info "Eseguendo download..."
    cd "$WEBTOON_DOWNLOADER_DIR" || {
        print_error "Impossibile accedere a $WEBTOON_DOWNLOADER_DIR"
        return 1
    }
    
    if eval "$cmd"; then
        print_success "Download completato"
        
        if [[ "$download_only" != "true" ]]; then
            print_info "Cercando directory scaricata..."
            
            # Trova directory create dopo il timestamp
            local found_dirs=()
            while IFS= read -r -d '' dir; do
                if [[ -d "$dir" ]]; then
                    local dir_time
                    dir_time=$(stat -c %Y "$dir" 2>/dev/null || echo 0)
                    if [[ $dir_time -gt $timestamp_before ]]; then
                        found_dirs+=("$dir")
                        print_verbose "Directory trovata: $dir"
                    fi
                fi
            done < <(find "$DOWNLOAD_DIR" -maxdepth 1 -type d -print0 2>/dev/null)
            
            if [[ ${#found_dirs[@]} -gt 0 ]]; then
                # Usa la directory più recente
                local latest_dir="${found_dirs[0]}"
                local latest_time=0
                
                for dir in "${found_dirs[@]}"; do
                    local dir_time
                    dir_time=$(stat -c %Y "$dir" 2>/dev/null || echo 0)
                    if [[ $dir_time -gt $latest_time ]]; then
                        latest_time=$dir_time
                        latest_dir="$dir"
                    fi
                done
                
                print_info "Directory trovata: $(basename "$latest_dir")"
                print_info "Avviando conversione automatica..."
                
                local output_dir="${latest_dir}_Kavita"
                convert_webtoon_directory "$latest_dir" "$output_dir"
                local convert_result=$?
                
                if [[ $convert_result -eq 0 && $NOTIFY_KAVITA -eq 1 ]]; then
                    notify_kavita_scan
                fi
                
                return $convert_result
            else
                print_warning "Nessuna directory scaricata trovata per conversione automatica"
                print_info "Controlla manualmente in: $DOWNLOAD_DIR"
                return 1
            fi
        fi
        
        return 0
    else
        print_error "Download fallito"
        return 1
    fi
}

# Modalità automazione
auto_mode() {
    if [[ $CRON_MODE -eq 0 ]]; then
        print_info "Modalità automazione avviata"
    fi
    
    if ! validate_config; then
        print_error "Configurazione non valida per modalità automazione"
        print_info "Esegui: $0 --setup"
        return 1
    fi
    
    # Controlla se ci sono serie da monitorare
    if [[ ! -f "$SERIES_DB" ]] || ! grep -q -v '^#' "$SERIES_DB" 2>/dev/null; then
        if [[ $CRON_MODE -eq 0 ]]; then
            print_info "Nessuna serie configurata per il monitoraggio automatico"
            print_info "Aggiungi serie con: $0 --add-series <url>"
            print_info "Lista serie con: $0 --list-series"
        fi
        return 0
    fi
    
    # Esegui check aggiornamenti
    check_updates
    return $?
}

# Funzione principale
main() {
    parse_args "$@"
    load_config
    
    case "$MODE" in
        setup)
            setup_wizard
            ;;
        convert)
            # Per conversione, la configurazione Webtoon-Downloader non è necessaria
            # Valida solo se si vuole usare notifiche Kavita
            if [[ $NOTIFY_KAVITA -eq 1 ]] && ! validate_config; then
                print_warning "Configurazione Kavita non valida per notifiche"
                NOTIFY_KAVITA=0
            fi
            convert_webtoon_directory "$SOURCE_DIR" "$OUTPUT_DIR"
            if [[ $? -eq 0 && $NOTIFY_KAVITA -eq 1 ]]; then
                notify_kavita_scan
            fi
            ;;
        download)
            if ! validate_config; then
                print_error "Configurazione non valida per download"
                print_info "Esegui: $0 --setup"
                exit 1
            fi
            download_webtoon "$WEBTOON_URL" "false"
            ;;
        download-only)
            if ! validate_config; then
                print_error "Configurazione non valida per download"
                print_info "Esegui: $0 --setup"
                exit 1
            fi
            download_webtoon "$WEBTOON_URL" "true"
            ;;
        add-series)
            add_series "$WEBTOON_URL"
            ;;
        remove-series)
            remove_series "$WEBTOON_URL"
            ;;
        list-series)
            list_series
            ;;
        check-updates)
            if ! validate_config; then
                print_error "Configurazione non valida per check aggiornamenti"
                print_info "Esegui: $0 --setup"
                exit 1
            fi
            check_updates
            ;;
        auto)
            auto_mode
            ;;
        *)
            print_error "Modalità non supportata: $MODE"
            exit 1
            ;;
    esac
}

# Controlla dipendenze
check_dependencies() {
    local missing=()
    
    if ! command -v zip >/dev/null 2>&1; then
        missing+=("zip")
    fi
    
    if ! command -v curl >/dev/null 2>&1; then
        missing+=("curl")
    fi
    
    if [[ ${#missing[@]} -gt 0 ]]; then
        print_error "Dipendenze mancanti: ${missing[*]}"
        print_info "Installa con: sudo apt-get install ${missing[*]}"
        exit 1
    fi
}

# Avvio script
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    check_dependencies
    main "$@"
fi